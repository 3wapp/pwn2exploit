## 二进制漏洞

## 漏洞类型
栈溢出, 格式化字符串, 堆溢出

## 常见保护机制

大部分在 `CSAPP` 的3.12节有提到, 主要是为了对抗缓冲区溢出攻击

#### 1. 栈随机化(ASLR)
内存地址随机化, 可以蛮力枚举, 并且可以通过 `nop sled` 可以大大减少尝试次数.
#### 2. 栈保护(canary)
就是段寄存器中取一个值放到栈中, 之后在函数结束时判断该值是否放生修改.

```
Dump of assembler code for function echo:
   0x0804849d <+0>:     push   ebp
   0x0804849e <+1>:     mov    ebp,esp
   0x080484a0 <+3>:     sub    esp,0x28
   0x080484a3 <+6>:     mov    eax,gs:0x14 //CANNARY 值
=> 0x080484a9 <+12>:    mov    DWORD PTR [ebp-0xc],eax
   0x080484ac <+15>:    xor    eax,eax
       0x080484ae <+17>:    lea    eax,[ebp-0x14]
   0x080484b1 <+20>:    mov    DWORD PTR [esp],eax
   0x080484b4 <+23>:    call   0x8048350 <gets@plt>
   0x080484b9 <+28>:    lea    eax,[ebp-0x14]
   0x080484bc <+31>:    mov    DWORD PTR [esp],eax
   0x080484bf <+34>:    call   0x8048370 <puts@plt>
   0x080484c4 <+39>:    mov    eax,DWORD PTR [ebp-0xc]
   0x080484c7 <+42>:    xor    eax,DWORD PTR gs:0x14
   0x080484ce <+49>:    je     0x80484d5 <echo+56>
   0x080484d0 <+51>:    call   0x8048360 <__stack_chk_fail@plt>
   0x080484d5 <+56>:    leave
   0x080484d6 <+57>:    ret
End of assembler dump.
```
#### 3. NX(DEP)
数据内存页不可执行, 栈数据不可执行

## 触发恶意函数的方法
#### 代码注入类
栈溢出后在栈上执行代码 - 受NX(DEP) 和 栈保护限制

#### 伪造替换正常函数
修改正常函数 `.got.plt` 地址, 指向恶意函数.

ret_2_dl_resolve

## ROP 返回导向编程

使用 `rop` 方法进行利用, 关键在于不发生代码注入, 直接绕过了 `NX(DEP)`. 根据利用 `ret` 的特性(`pop` 栈中元素作为返回地址), 利用类似包含 `ret` 的一段段 `gadgets` 构造完整恶意的函数调用.

`rop` 有四个关键点.

#### 0. 控制栈(stack)数据
这个是利用前提.

#### 1. 泄露关键函数地址
泄露函数地址的方法:

* 根据已知函数的 `.got` 表地址, 以及 `libc` 文件计算两个符号间的偏移.
* 根据 `DynELF` 进行文件解析, 大致就是解析 `ELF` 结构, 原理可以参考 `so` 注入过程如何查找 `__libc_dlopen_mode` 方法.

#### 2. 构造ROP利用链

#### 3. 触发ROP链
