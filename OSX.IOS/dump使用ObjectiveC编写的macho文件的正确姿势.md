## dump使用ObjectiveC编写的macho文件的正确姿势

#### 问题1: 如何访问目标进程内存空间

使用 `task_for_pid` 取得对应的 `task_t` , 这里简单介绍下内部机制, 我也没有具体深究, 这个 `task_t` 的处理方式, 有些类似于 ELF 中 `link_map`, `link_map ` 对于用户 inlcude 的头文件和 libc 在进行链接加载时, 是两个不同的数据结构, 在链接加载时具有更多的成员. `task_t` 也是如此, 对于用户层而言仅为一个数字, 但是在内核处理, 该数据结构包含了该进程很多信息, 内存页的具体映射等等. 

之后利用 `vm_read_overwrite` 访问目标内存空间

#### 问题2: Macho文件的解析的起始位置

Macho 文件的加载是经过 ASLR 的, 所以我们需要获取到程序的加载地址. 这里获取程序的加载地址有几种方式.

```
1. task_info

2. vm_region 这个原理就是内核有个表记录了所有虚拟内存映射 用户层访问不到, 可以参考下面
http://stackoverflow.com/questions/10301542/getting-process-base-address-in-mac-osx

3. 部分暴力内存搜索, 根据虚拟内存页和xnu的aslr特点, 可以限定内存搜索范围, 其实和上面有些类似
https://github.com/jmpews/evilMACHO/tree/master/dumpRuntimeMacho
```

