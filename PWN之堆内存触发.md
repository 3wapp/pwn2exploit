#### 参考资料

```
#最好按照参考资料顺序查看
#malloc理解
<PWN之堆内存管理.md>

#介绍常用漏洞, 如何由BUG到Primitive, 再如何到Exploit
2002.gera.About_Exploits_Writing.pdf

#unlink参考资料
#都是讲unlink 和 unlink 的绕过的, 但是总感觉对于 unlik 绕过保护机制那块没有讲出原理.
#因该是free@plt, 而不是 free@got, 因为 ELF 将 got 表拆分为两部分 `.got`, `.got.plt`, 详细查看 <PWN之ELF解析.md>
http://static.hx99.net/static/drops/tips-7326.html
http://www.ms509.com/?p=49
#只讲到 unlink, 没有提及绕过, 但是讲到一些检测机制.
https://jaq.alibaba.com/community/art/show?articleid=360

#感觉这作者好厉害, 有自己的一个对漏洞的全方位理解, 很透彻.
http://www.freebuf.com/articles/system/91527.html

https://googleprojectzero.blogspot.jp/2014/08/the-poisoned-nul-byte-2014-edition.html(Project Zero)
https://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf (off-by-one 总结)
http://angelboy.logdown.com/posts/262325-plaid-ctf-2015-write-up (shrink free chunk size)
http://blog.frizn.fr/pctf-2015/pwn-550-plaiddb (shrink free chunk size)
http://netsec.ccert.edu.cn/wp-content/uploads/2015/10/2015-1029-yangkun-Gold-Mining-CTF.pdf (内存pwn 总结)
```
## 0x00 堆漏洞综述

在这里我们仅讨论 `Turning bugs into primitives` 的过程,

## 0x01 unlink

#### 导致(最终结果):

**实现任意内存地址写内容, 具体来说是借助 unlink 进行写, 我们只需要构造好数据即可.**

#### 原理(触发原因):

unlink 进行地址内容写操作没有进行检查. unlink 操作是从 chunk 双向环中摘除节点, 一般来说会在 malloc 时触发, 但是当需要 free 的 chunk 前后也有空闲 chunk, 会进行空闲 chunk 的合并, 这时需要 unlink 那个需要合并的空闲 chunk.

```
#define unlink( P, BK, FD ) {
BK = P->bk;
FD = P->fd;
FD->bk = BK;
BK->fd = FD;
}
```

由于堆的内容是可以控制的, FD 和 BK 均为可以控制的, 由此导致任意地址写内容.

#### 触发前提(限制):

free 的 chunk 前后存在空闲 chunk, 也可以通过溢出值覆盖需要 free 的 chunk 的 `P` 位, 能控制需要 unlink 的 chunk 的内容.

#### 保护机制:

```
eglibc-2.19/malloc/malloc.c:1410
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))         \
  malloc_printerr (check_action, "corrupted double-linked list", P);      \
```

为什么这个判断可以防止 unlink 攻击, 首先很明确, `FD` 和 `BK`内容可控, 由于要求 `*(FD+24) == P && *(BK+16) == P`, 对 `FD` 和 `BK` 进行了限定, 即使可以找到内存中某个地址 `(FD+24)` , 使 `*(FD+24) == P` 成立, 但是当进行 `FD->bk = BK; BK->fd = FD`, 也会出现写入的地址不是关键地址, 写入的内容也不是我们想要的, 因此 `任意地址写任意内容` 变为 `限制地址写限制内容`, 导致无法被利用, 更何况这还需要找一个泄露任意地址内容的方法.

#### 绕过保护机制:

这个保护机制的绕过, 个人感觉不算是绕过, 应该是妥协了这个保护机制. 既然保护机制要求 `FD->bk == P && BK->fd == P`, 也就是说 ` *(FD+24) == P`, 再推理, 也就是 `*((P->fd) + 24) == P`, 这里存在一个 `*` 取值符, 所以我们需要一个已知地址的指针, 并且该指针指向 P, 假设 `*ptr = P`, 设 `P->fd = ptr - 24`, 这样就可以通过保护机制. 但是我们找到这样一个指针只能算是 `通过` 了保护机制, 然而如何利用这个指针实现任意地址写的需要进一步利用, 将在下面介绍由此导致的漏洞.


#### 利用思路:

构造好 `P->bk` 和 `P->fd` 的值, 比如现在需要当调用 `free` 执行 `shellcode`, 这里需要的注意的因为 `free` 需要进行延迟绑定的, 所以 `.got.plt` 存放了解析后 `free` 函数的内存地址, 这也对应了 `*((P->fd) + 24) == P` 的 `*` 操作. 所以我们可以直接构造 `P->fd = <free@plt> + 24`, `P->bk = shellcode 地址`, 当进行 unlink 操作时, 触发 `FD->bk = BK`, 修改 `free@plt` 内容为 `shellcode` 地址, 同时为了避免 `BK->fd = FD` 的影响, 需要将 `shellcode` 的前面一小段字节设为 `nop`.

## 0x02 unlink(通过保护机制)
#### 导致(最终结果):

**实现任意内存地址写内容; 修改了 chunk 的起始地址, 写入操作无需借助系统函数, 用户主动进行写操作 .**

#### 原理(触发原因):

**内存覆盖(memory overlap), 个人觉得这才是根本原因.**

根据上面的保护机制绕过.

> 这个保护机制的绕过, 个人感觉不算是绕过, 应该是妥协了这个保护机制. 既然保护机制要求 `FD->bk == P && BK->fd == P`, 也就是说 ` *(FD+24) == P`, 再推理, 也就是 `*((P->fd) + 24) == P`, 这里存在一个 `*` 取值符, 所以我们需要一个已知地址的指针, 并且该指针指向 P, 因为此 `*ptr = P`, 设 `P->fd = ptr - 24`, 这样就可以通过保护机制. 但是我们找到这样一个指针只能算是 `通过` 了保护机制, 然而如何利用这个指针实现任意地址写的需要进一步利用, 将在下面介绍由此导致的漏洞.

上面的整个过程可以理解为伪造了两个 fake chunk, `ptr -24` 和 `ptr - 16` 其实就是这两个 fake chunk 的起始地址.

之后进行 unlink 操作, 触发 `BK->fd = FD` 也就是 `*ptr = FD = ptr - 24`, 这句话修改了 `*ptr` 指向 chunk 的地址. 更重要的是 `*ptr` 指向的 fake chunk, 与 `ptr` 发生了重叠, 更具体来说 `*ptr` 指向的 chunk 的范围是 `[ptr - 24, ptr+]`, 并且正好有权限去控制 `*ptr` 指向的 chunk 的内容, 进而修改 `*ptr` 内容为我们希望写入的关键地址, 比如: `free@plt`, 由于 `*ptr` 的发生改变, 此时 `*ptr` 指向 chunk 的起始地址变为 `free@plt`, 此时我们再对 `*ptr` 指向的 fake chunk 进行修改, 就发生就可以修改 `free` 的函数地址为 `shellcode 地址` 或者其他关键函数地址.

#### 触发前提(限制):

0. 能够触发 unlink
1. 需要一个已知地址(设改地址为ptr)指针, 该指针指向 P, 也就是 `*ptr == P`
2. 可以重复修改 `*ptr` 指向的 chunk 的内容

#### 保护机制:
这里主要是利用 unlink 修改了指向 chunk 的地址, 之后由用户进行主动写操作, 对于 unlink 的防护, 我们已经伪造了 fake chunk, 该防护失效.

#### 利用思路:

见 `原理(触发原因)`

## 0x03 off-by-one

## Null Byte Off-by-one

#### PlaidDB(pwn 550)
