#### 参考资料

http://blog.frizn.fr/pctf-2015/pwn-550-plaiddb (shrink free chunk size)
https://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf (off-by-one 总结)
http://angelboy.logdown.com/posts/262325-plaid-ctf-2015-write-up (shrink free chunk size)
http://netsec.ccert.edu.cn/wp-content/uploads/2015/10/2015-1029-yangkun-Gold-Mining-CTF.pdf (内存pwn 总结)

## unlink

unlink 操作是从 chunk 双向环中摘除节点, 一般来来说会在 malloc 时触发, 但是当需要 free 的 chunk 前后也有空闲 chunk, 会进行空闲 chunk 的合并, 这时需要 unlink 需要合并的空闲 chunk, 最终导致漏洞触发.

实现结果: **实现任意内存地址写**

触发前提: 需要 free 的 chunk 前后存在空闲 chunk.

触发原因: 见上.

```
#define unlink( P, BK, FD ) {
BK = P->bk;
FD = P->fd;
FD->bk = BK;
BK->fd = FD;
}
```

目前防护:

```
eglibc-2.19/malloc/malloc.c:1410
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))         \
  malloc_printerr (check_action, "corrupted double-linked list", P);      \
```

## off-by-one

#### PlaidDB(pwn 550)

```
|40|20|110|
|40|20|110|40|20|230| -> |40|20|*110|*40|*20|230|
|40|20|90|*80|40|20|230| //do_put("k2", "C"*0x80)
|40|20|90|(k3)40|20|*20|40|20|230|240| //do_put("k3", "D"*0x230)

|*40|*20|90|40|20|*20|(k2)40|20|*230|240| //do_del("k1")
|*40|*20|*90|40|20|*20|*40|*20|*230|240| //do_del("k2")

|*40|20|*90|40|20|*20|(k4)40|*20|*230|240| put(k4)
|(kk)40|20|*90|40|20|*20|(k4)40|*20|*230|240| put(k4)
|(kk)40|20|*90|40|20|*20|(k4)40|*20|110|40|*b0|240| put(k4)


```
