## 堆漏洞触发

## 参考资料

```
<docs/glibc内存管理ptmalloc源代码分析.pdf>
```


关于堆的分配原理我觉的这篇文章 `<docs/glibc内存管理ptmalloc源代码分析.pdf>` 已经说得很详细.

#### 操作系统内存的相关函数

`heap` 相关函数: `brk`, `sbrk`.

`mmap` 映射区域函数

 可以参考实践 `https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/?spm=a313e.7916648.0.0.H9xzd9`

 #### 内存管理的数据结构

主分配区(Main_arena) 和 非主分配区, 主要是为了应多线程的情况.

---

`chunk` 结构

```
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```
注意 `chunk` 的空间复用

---

空闲 `chunk` 结构, 存储在 `bins` 数组中, 每一个 `bin` 就是一个双向环形链表, 分为以下几种.

`Fast Bins`, `Unsorted Bin`, `top chunk`, `mmaped chunk`, `Last remainder`

**`top chunk` 与 主分配区, 非主分配区, `sub-heap` 的关系?**

首先 `top chunk` 是针对稍微大一点的内存而言, `top chunk` 在分配时总是在 `fast bins` 和 `bins` 之后被考虑.

`top chunk` 对于主分区而言, 第一次调用 malloc 时会分配一块 `(chunk_size + 128KB) align 4KB` 大小的空间作为初始的 `heap`.

对于非主分区而已, 会预先从 `mmap` 区域分配一块较大的空闲内存模拟 `sub-heap`, 如果 `top chunk` 不够大分配程序会重新分配一个 `sub-heap`, 并将 `top chunk` 迁移到新的 `sub-heap` 上, 新的 `sub-heap` 与已有的 `sub-heap` 用单向链表连接起来.
