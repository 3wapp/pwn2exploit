#### 参考资料

```
#最好按照参考资料顺序查看
https://googleprojectzero.blogspot.jp/2014/08/the-poisoned-nul-byte-2014-edition.html(Project Zero)
https://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf (off-by-one 总结)
http://angelboy.logdown.com/posts/262325-plaid-ctf-2015-write-up (shrink free chunk size)
http://blog.frizn.fr/pctf-2015/pwn-550-plaiddb (shrink free chunk size)
http://netsec.ccert.edu.cn/wp-content/uploads/2015/10/2015-1029-yangkun-Gold-Mining-CTF.pdf (内存pwn 总结)
```

## unlink

#### 原理(触发原因):
unlink 操作是从 chunk 双向环中摘除节点, 一般来说会在 malloc 时触发, 但是当需要 free 的 chunk 前后也有空闲 chunk, 会进行空闲 chunk 的合并, 这时需要 unlink 那个需要合并的空闲 chunk.

```
#define unlink( P, BK, FD ) {
BK = P->bk;
FD = P->fd;
FD->bk = BK;
BK->fd = FD;
}
```

由于堆的内容是可以控制的, FD 和 BK 均为可以控制的, 由此导致任意地址写内容.

#### 触发前提:

free 的 chunk 前后存在空闲 chunk, 也可以通过溢出值覆盖需要 free 的 chunk 的 `P` 位, 能控制需要 unlink 的 chunk 的内容.

#### 导致(最终结果):

**实现任意内存地址写内容, 具体来说是借助 unlink 进行写, 我们只需要构造好数据即可.**

#### 保护机制:

```
eglibc-2.19/malloc/malloc.c:1410
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))         \
  malloc_printerr (check_action, "corrupted double-linked list", P);      \
```

为什么这个判断可以防止 unlink 攻击, 首先很明确, `FD` 和 `BK`内容可控, 由于要求 `*(FD+24) == P && *(BK+18) == P`, 对 `FD` 和 `BK` 进行了限定, 即使可以找到内存中某个地址 `(FD+24)` , 使 `*(FD+24) == P` 成立, 但是当进行 `FD->bk = BK; BK->fd = FD`, 也会出现写入的地址不是关键地址, 写入的内容也不是我们想要的, 因此 `任意地址写任意内容` 变为 `限制地址写限制内容`, 导致无法被利用, 更何况这还需要找一个泄露任意地址内容的方法.

#### 绕过保护机制:

这个保护机制的绕过, 个人感觉不算是绕过, 应该是妥协了这个保护机制. 既然要求 `FD->bk == P && BK->fd == P`, 也就是说 ` *(FD+24) == P`, 再推理, 也就是 `*((P->fd) + 24) == P`, 这里存在一个 `*` 取值符, 所以我们需要一个已知地址的指针, 该指针指向 P, 假设 `*ptr = P`, 设 `P->fd = ptr - 18`, 这样就可以 `通过` 保护机制. 当我们找到这样一个指针只能算是 `通过` 了保护机制, 然而如何利用这个指针实现任意地址写的需要进一步利用, 将在下面介绍由此导致的漏洞.


#### 利用思路:
构造好,


## off-by-one

## Null Byte Off-by-one

#### PlaidDB(pwn 550)
