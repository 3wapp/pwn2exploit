# ELF结构和动态符号解释

---
## 调试技巧
#### gdb 调试 glibc
```
http://hardenedlinux.org/toolchains/2016/08/25/build_debug_environment_for_dynamic_linker_of_glibc.html
http://blog.nlogn.cn/trace-glibc-by-using-gdb/
```

---
## ELF相关结构解释

在解释ELF结构时以下面源码为例子:

```
#include <stdio.h>

int helloWorld(){
    printf("HelloWorld, %d\n", 1);
    return 0;
}

int main(){
    helloWorld();
    printf("HelloWorld, %d\n", 1);
    return 0;
}
```
查看ELF的 `section` 

```
➜  elf readelf -S test
There are 30 section headers, starting at offset 0x1154:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4
  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4
  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4
  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4
  [11] .init             PROGBITS        080482b4 0002b4 000023 00  AX  0   0  4
  [12] .plt              PROGBITS        080482e0 0002e0 000040 04  AX  0   0 16
  [13] .text             PROGBITS        08048320 000320 0001a2 00  AX  0   0 16
  [14] .fini             PROGBITS        080484c4 0004c4 000014 00  AX  0   0  4
  [15] .rodata           PROGBITS        080484d8 0004d8 000018 00   A  0   0  4
  [16] .eh_frame_hdr     PROGBITS        080484f0 0004f0 000034 00   A  0   0  4
  [17] .eh_frame         PROGBITS        08048524 000524 0000d0 00   A  0   0  4
  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4
  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4
  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4
  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4
  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        0804a000 001000 000018 04  WA  0   0  4
  [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4
  [25] .bss              NOBITS          0804a020 001020 000004 00  WA  0   0  1
  [26] .comment          PROGBITS        00000000 001020 00002b 01  MS  0   0  1
  [27] .shstrtab         STRTAB          00000000 00104b 000106 00      0   0  1
  [28] .symtab           SYMTAB          00000000 001604 000440 10     29  45  4
  [29] .strtab           STRTAB          00000000 001a44 00025c 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
```

下面对几个 `section` 具体解释下
#### `.got.plt` 表
> `ELF` 将 `GOT` 拆分为两个表, `.got` 和 `.got.plt`. 其中 `.got` 用来保存全局变量引用的地址, `.got.plt` 用来保存函数引用的地址, 对于外部函数的引用全部放在 `.got.plt` 中. --- <程序员的自我修养> P201

**结构**

前三项是固定的, 第一项是 `.dynamic` 的地址, 第二项是 `link_map` 的地址, 第三项是 `_dl_runtime_resolve()` 的地址, 之后就是每个外部函数的引用的数据结构 `Elf32_Rel`

````
typedef struct
{
  Elf32_Addr	r_offset;		/* Address */
  Elf32_Word	r_info;			/* Relocation type and symbol index */
} Elf32_Rel
````

**未执行前`.got.plt`结构**

`.got.plt` 中对应的前四项

```
gdb-peda$ x/4w 0x0804a000 #对应.got.plt
0x804a000:	0x08049f14	0x00000000	0x00000000	0x080482f6
```

`.plt(延迟绑定)` 中对应的实现

```
gdb-peda$ x/4i 0x80482f0 #对应.plt
   0x80482f0 <printf@plt>:    jmp    DWORD PTR ds:0x804a00c
   0x80482f6 <printf@plt+6>:  push   0x0
   0x80482fb <printf@plt+11>: jmp    0x80482e0
```

可以看到 `.dynamic` 对应的地址是 `0x08049f14`, 后两项由于未初始化为空, `0x080482f6` 为第一个外部函数的引用地址, 此时没有初始化, 会跳转到 `.plt` 表进行初始化, 初始化后会修改 `0x080482f6` 为 `printf` 的地址. (至于为什么是`0x080482f6`, 而不是 `0x80482f0`, 因为没有初始化, 需要从 `0x80482f6` 地址开始进行初始化, 当初始化完毕后才会从 `0x80482f0` 直接跳转到 `printf` 继续执行)

---

**初始化完毕 `.got.plt` 结构**

`.got.plt` 中对应的前四项

```
gdb-peda$ x/4w 0x0804a000 #.got.plt
0x804a000:	0x08049f14	0xb7fff938	0xb7ff24b0	0xb7e71410
```
此时 `.got.plt` 中的地址已经被修改为 `printf` 的地址.

---
#### `.plt` 延迟绑定表(程序员自我修养P201)

```
gdb-peda$ disassemble helloWorld
Dump of assembler code for function helloWorld:
   0x0804841d <+0>: 	push   ebp
   0x0804841e <+1>: 	mov    ebp,esp
   0x08048420 <+3>: 	sub    esp,0x18
   0x08048423 <+6>: 	mov    DWORD PTR [esp+0x4],0x1
   0x0804842b <+14>:	mov    DWORD PTR [esp],0x80484e0
   0x08048432 <+21>:	call   0x80482f0 <printf@plt>
   0x08048437 <+26>:	mov    eax,0x0
   0x0804843c <+31>:	leave
   0x0804843d <+32>:	ret
End of assembler dump.
```

负责延迟加载, 当第一次调用时, 会用 `_dl_runtime_resolve()` 去初始化 `.got.plt` 中的函数引用地址.

```
gdb-peda$ x/4i 0x80482f0
   0x80482f0 <printf@plt>:	jmp    DWORD PTR ds:0x804a00c
   0x80482f6 <printf@plt+6>:	push   0x0
   0x80482fb <printf@plt+11>:	jmp    0x80482e0
```

---
#### `.dynsym` 和 `.dynstr` (`.symtab` 和 `.strtab`)

`.dynsym` 中保存的是 `Elf32_Sym` 结构. 

```
typedef struct
{
  Elf32_Word	st_name;		/* Symbol name (string tbl index) */
  Elf32_Addr	st_value;		/* Symbol value */
  Elf32_Word	st_size;		/* Symbol size */
  unsigned char	st_info;		/* Symbol type and binding */
  unsigned char	st_other;		/* Symbol visibility */
  Elf32_Section	st_shndx;		/* Section index */
} Elf32_Sym
```

`.dynstr` 保存的字符串, 具体存放格式 `<Tool Interface Standard (TIS) Executable and Linking Format (ELF)> 中 Book I: String Table` 或者 `<程序员自我修养> P80`

`readelf --dyn-syms test`, 与内存和 `Elf32_Sym` 对比

```
➜  elf python -c 'print int(0x50)';python -c 'print hex(0x00021c+0xb)' #下面需要用到
80
0x227
➜  elf readelf --dyn-syms test

Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
     4: 080484fc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
➜  elf hexdump -s 0x0001cc -n 80 -C test #
000001cc  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001dc  1a 00 00 00 00 00 00 00  00 00 00 00 12 00 00 00  |................|
000001ec  33 00 00 00 00 00 00 00  00 00 00 00 20 00 00 00  |3........... ...|
000001fc  21 00 00 00 00 00 00 00  00 00 00 00 12 00 00 00  |!...............|
0000020c  0b 00 00 00 fc 84 04 08  04 00 00 00 11 00 0f 00  |................|
0000021c
➜  elf hexdump -s 0x227 -n 15 -C test #根据 .dynsym 中的 Elf32_Sym 结构查找到对应字符串, 
00000227  5f 49 4f 5f 73 74 64 69  6e 5f 75 73 65 64 00     |_IO_stdin_used.|
00000236
```

---
#### `.rel.plt` 重定位表

查看需要重定位的函数引用

```
➜  elf readelf -r test

Relocation section '.rel.dyn' at offset 0x294 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x29c contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   printf
0804a010  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a014  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main
```

查看 `Elf32_Rel` 结构, `0x804a00c` 重定位的入口偏移(未初始化前存放的是对应`.plt`的初始化代码, 初始化后存放`printf`地址), `0x107` 低8位表示重定位入口类型为 `R_386_JUMP_SLOT(7)`, 高24位表示在 `.dynsym` 中的下标, 这里为1.

```
gdb-peda$ x/6w 0x0804829c
0x804829c:	0x804a00c	0x107	0x804a010	0x207
0x80482ac:	0x804a014	0x307
gdb-peda$ x/w 0x804a00c
0x804a00c <printf@got.plt>:	0x80482f6
➜  elf readelf -r test

Relocation section '.rel.dyn' at offset 0x294 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x29c contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   printf
0804a010  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a014  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main
➜  elf readelf --dyn-syms test

Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
     4: 080484fc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
```

---
#### `.gnu.hash` 表

参考链接:

```
http://pank.org/blog/2007/10/gcc-hashstylegnu.html (大致意思就是目前默认生成新的hash表, 也就是.gnu.hash)
https://sourceware.org/ml/binutils/2006-10/msg00377.html(实例代码更接近实际)
https://www.sourceware.org/ml/binutils/2006-06/msg00418.html 
https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections (最详细)
```

`.gnu.hash` 的作用, 主要是利用 `Bloom Filter`, 在常量时间内判断, 字符是否存在, 以及对应 `.dynsym` 的位置. 使用 `gcc -g -o hello -Wl,--hash-style=sysv(gnu) hello.c` 可以产生旧版本的 `hash` 表.

`.gnu.hash` 结构说明:

```
Header
    An array of (4) 32-bit words providing section parameters:
    nbuckets
        The number of hash buckets
    symndx
        The dynamic symbol table has dynsymcount symbols. symndx is the index of the first symbol in the dynamic symbol table that is to be accessible via the hash table. This implies that there are (dynsymcount - symndx) symbols accessible via the hash table.
        第一个需要hash的symbol
    maskwords
        The number of ELFCLASS sized words in the Bloom filter portion of the hash table section. This value must be non-zero, and must be a power of 2 as explained below.
        Note that a value of 0 could be interpreted to mean that no Bloom filter is present in the hash section. However, the GNU linkers do not do this — the GNU hash section always includes at least 1 mask word.
        Bloom filter中掩码个数, 每个掩码可以为32位大小, 或者64位大小
    shift2
        A shift count used by the Bloom filter.
        另一个hash函数
Bloom Filter(32位大小)
    GNU_HASH sections contain a Bloom filter. This filter is used to rapidly reject attempts to look up symbols that do not exist in the object. The Bloom filter words are 32-bit for ELFCLASS32 objects, and 64-bit for ELFCLASS64.
    Bloom filter中的掩码
Hash Buckets(32位大小)
    An array of nbuckets 32-bit hash buckets
    对应的symbol的number, 参考 `readelf --dyn-syms test` 成成的结果
Hash Values(32位大小)
    An array of (dynsymcount - symndx) 32-bit hash chain values, one per symbol from the second part of the dynamic symbol table.
    hash值, 需要计算, 但绝大数都是 `dl_new_hash()` 的返回值
```
查看 `.gnu.hash` 结构, 使用 `hexdump` 或者 `gdb` 都可以查看.

```
➜  elf hexdump -s 0x0001ac -n 32 -e '4/4 "%04X " " | "' -e '16/1 "%_p" "\n"' test
0002 0004 0001 0005 | ................
20002000 0000 0004 C0E34BAD | . . .........K..

```

```
gdb-peda$ x/8w 0x080481ac
0x80481ac:	0x2       	0x4 	0x1 	0x5
0x80481bc:	0x20002000	0x0 	0x4 	0xc0e34bad
```
查看动态符号表

```
➜  elf readelf --dyn-syms test

Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
     4: 080484fc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
```


对应说明, `nbuckets == 2` 表明有两个 `dynsym` 需要hash, `symndx == 4` 表明第1个需要hash的`dymsym` 的num为4, 参考上表, `maskwords == 1` 表明有1个Bloom filter掩码, `shift2 == 5` 表明另一个hash函数为 `>>5` (查看Bloom filter算法结构定义, 这里使用了k=2个hash函数, 没事设置hash值对应位置为1, 防止误判)

`20002000` 即为掩码, 初始为0, 怎么发生修改的:

```
本段内容来自 https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections
The hash function used by the GNU hash has this property. This fact is leveraged to produce both hash functions required by the Bloom filter from the single hash function described above:
两个hash函数
    H1 = dl_new_hash(name);
    H2 = H1 >> shift2;
As discussed above, the link editor determines how many mask words to use (maskwords) and the amount by which the first hash result is right shifted to produce the second (shift2). The more mask words used, the larger the hash section, but the lower the rate of false positives. I was told in private email that the GNU linker primarily derives shift2 from the base 2 log of the number of symbols entered into the hash table (dynsymcount - symndx), with a minimum value of 5 for ELFCLASS32, and 6 for ELFCLASS64. These values are explicitly recorded in the hash section in order to give the link editor the flexibility to change them in the future should better heuristics emerge.
The Bloom filter mask sets one bit for each of the two hash values. Based on the Bloom filter reference, the word containing each bit, and the bit to set would be calculated as:
这是根据Bloom filter定义给出的参考, 但实际gnu用了一个此算法的修改版. 这里C是上面提到的 Bloom filter 掩码大小. 这里是32位
    N1 = ((H1 / C) % maskwords);
    N2 = ((H2 / C) % maskwords);
    
    B1 = H1 % C;
    B2 = H2 % C;
To populate the bits when building the filter:
    bloom[N1] |= (1 << B1);
    bloom[N2] |= (1 << B2);
and to later test the filter:
    (bloom[N1] & (1 << B1)) && (bloom[N2] & (1 << B2))
    
Therefore, in the GNU hash, the single mask word is actually calculated as:
因此gnu的算法描述如下, 总体类似.
    N = ((H1 / C) % maskwords);
The two bits set in the Bloom filter mask word N are:
    BITMASK = (1 << (H1 % C)) | (1 << (H2 % C));
The link-editor sets these bits as
    bloom[N] |= BITMASK;
And the test used by the runtime linker is:
    (bloom[N] & BITMASK) == BITMASK;
```

**这里进行一个实例的计算:**

使用这段代码计算 `_IO_stdin_used` 的hash值.

```
#include <stdio.h>
#include <libelf/libelf.h>

uint32_t
dl_new_hash (const char *s)
{
        uint32_t h = 5381;

        for (unsigned char c = *s; c != '\0'; c = *++s)
                h = h * 33 + c;

        return h;
}
int main(int argc, char** argv) {
   printf("%zu", dl_new_hash(argv[1]));
   return 0;
}
```

对应 `.gnu.hash` 结构

```
gdb-peda$ x/8w 0x080481ac
0x80481ac:  0x2         0x4     0x1     0x5
0x80481bc:  0x20002000  0x0     0x4      
```

下面为计算过程

```
➜  elf ./a.out _IO_stdin_used
3236121517%
➜  elf python -c 'print int(3236121517%32)' #Hash1算法, 对应B1
13
➜  elf python -c 'print int((3236121517>>5)%32)' #Hash2算法, 对应B2
29
所以:
    N = 0
    BITMASK = (1 << 13)) | (1 << 29)) = 0x20002000
    bloom[N] |= BITMASK
所以:
    bloom[0] = 0x20002000
```

`0x0	0x4` 是 `Hash Buckets`, 关于hash中如何利用桶解决hash冲突 `http://www.cnblogs.com/xiekeli/archive/2012/01/16/2323391.html`

```
Hash Buckets

Following the Bloom filter are nbuckets 32-bit words. Each word N in the array contains the lowest index into the dynamic symbol table for which:
    (dl_new_hash(symname) % nbuckets) == N
Since the dynamic symbol table is sorted by the same key (hash % nbuckets), dynsym[buckets[N]] is the first symbol in the hash chain that will contain the desired symbol if it exists.
A bucket element will contain the index 0 if there is no symbol in the hash table for the given value of N. As index 0 of the dynsym is a reserved value, this index cannot occur for a valid symbol, and is therefore non-ambiguous.
```
继续上面的实例计算:

```
➜  elf python -c 'print int(3236121517%2)'

N = 1
buckets[N] = 0x4
dynsym[0x4] = _IO_stdin_used
```

`0xc0e34bad ` 是 `Hash Values`

```
The final part of a GNU hash section contains (dynsymcount - symndx) 32-bit words, one entry for each symbol in the second part of the dynamic symbol table. The top 31 bits of each word contains the top 31 bits of the corresponding symbol's hash value. The least significant bit is used as a stopper bit. It is set to 1 when a symbol is the last symbol in a given hash chain:
前31位作为hash值, 最后一位作为分割, 当symbol为最后一个或者两个桶的边界, 都要将最后一位置为1
    lsb = (N == dynsymcount - 1) ||
      ((dl_new_hash (name[N]) % nbuckets)
       != (dl_new_hash (name[N + 1]) % nbuckets))
    
    hashval = (dl_new_hash(name) & ~1) | lsb;

或者可以参考这个算法
(dl_new_hash (&.dynstr[.dynsym[N].st_name]) & ~1)
| (N == dynsymcount - 1
   || (dl_new_hash (&.dynstr[.dynsym[N].st_name]) % nbuckets)
      != (dl_new_hash (&.dynstr[.dynsym[N + 1].st_name]) % nbuckets))
```
这段一共有 `dynsymcount - symndx` 个32-bit.

最后分析一段GNU中利用symbol-name返回指向该symbol的指针. 这里需要理解下, hash算法中利用桶解决冲突的原理, 冲突后需要在桶内进行查找, 时间复杂度为O(1)+O(m), m为桶的固定大小.

```
Symbol Lookup Using GNU Hash

The following shows how a symbol might be looked up in an object using the GNU hash section. We will assume the existence of an in memory record containing the information needed:
typedef struct {
        const char      *os_dynstr;      /* Dynamic string table *//* .dynstr地址 */
        Sym             *os_dynsym;      /* Dynamic symbol table *//* .dynsym地址 */
        Word            os_nbuckets;     /* # hash buckets */
        Word            os_symndx;       /* Index of 1st dynsym in hash */
        Word            os_maskwords_bm; /* Bloom filter words, minus 1 */
        Word            os_shift2;       /* Bloom filter hash shift */
        const BloomWord *os_bloom;       /* Bloom filter words */
        const Word      *os_buckets;     /* Hash buckets */
        const Word      *os_hashval;     /* Hash value array */
} obj_state_t;
To simplify matters, we elide the details of handling different ELF classes. In the above, Word is a 32-bit unsigned value, BloomWord is either 32 or 64-bit depending in the ELFCLASS, and Sym is either Elf32_Sym or Elf64_Sym.
Given a variable containing the above information for an object, the following pseudo code returns a pointer to the desired symbol if it exists in the object, and NULL otherwise.

Sym *
symhash(obj_state_t *os, const char *symname)
{
        Word            c;
        Word            h1, h2;
        Word            n;
        Word            bitmask; 
        const Sym       *sym;
        Word            *hashval;

        /*
         * Hash the name, generate the "second" hash
         * from it for the Bloom filter.
         */
        /* 两个散列函数 */
        h1 = dl_new_hash(symname);
        h2 = h1 >> os->os_shift2;

        /* Test against the Bloom filter */
        /* BloomWord的位大小 */
        c = sizeof (BloomWord) * 8;
        n = (h1 / c) & os->os_maskwords_bm;
        bitmask = (1 << (h1 % c)) | (1 << (h2 % c));
        if ((os->os_bloom[n] & bitmask) != bitmask)
                return (NULL);

        /* Locate the hash chain, and corresponding hash value element */
        /* 获取对应桶的第一个.dynsym索引 *
        n = os->os_buckets[h1 % os->os_nbuckets];
        if (n == 0)    /* Empty hash chain, symbol not present */
                return (NULL);
        /* Sym数据结构 */        
        sym = &os->os_dynsym[n];
        /* 获取对应桶的第一个hashval */
        hashval = &os->os_hashval[n - os->os_symndx];

        /*
         * Walk the chain until the symbol is found or
         * the chain is exhausted.
         */
        for (h1 &= ~1; 1; sym++) {
                /* 进行桶内遍历查询 */
                h2 = *hashval++;

                /*
                 * Compare the strings to verify match. Note that
                 * a given hash chain can contain different hash
                 * values. We'd get the right result by comparing every
                 * string, but comparing the hash values first lets us
                 * screen obvious mismatches at very low cost and avoid
                 * the relatively expensive string compare.
                 *
		 * We are intentionally glossing over some things here:
	         *
		 *    -  We could test sym->st_name for 0, which indicates
		 *	 a NULL string, and avoid a strcmp() in that case.
		 *
                 *    - The real runtime linker must also take symbol
		 * 	versioning into account. This is an orthogonal
		 *	issue to hashing, and is left out of this
		 *	example for simplicity.
		 *
		 * A real implementation might test (h1 == (h2 & ~1), and then
		 * call a (possibly inline) function to validate the rest.
                 */
                /* hash值相同并且name相同 */
                if ((h1 == (h2 & ~1)) &&
                    !strcmp(symname, os->os_dynstr + sym->st_name))
                        return (sym);

                /* Done if at end of chain */
                /* 桶内查询完毕,因为桶边界是最低位为1 */
                if (h2 & 1)
                        break;
        }

        /* This object does not have the desired symbol */
        return (NULL);
}
```

差不多把几个重要的section都介绍到了

---
## 动态链接解释过程

参考链接

```
<程序员自我修养>
http://www.longene.org/techdoc/0750005001224576724.html
http://blog.chinaunix.net/uid-21471835-id-441227.html(很全)
```

下面以该源程序分析整个动态链接解释符号的过程:

```
#include <stdio.h>
int main(int argc, char *argv[])
{
printf("Hello, world%d\n", 1);
return 0;
}
```
先查看section表

```
➜  hook readelf -S test
There are 30 section headers, starting at offset 0x1154:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4
  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4
  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4
  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4
  [11] .init             PROGBITS        080482b4 0002b4 000023 00  AX  0   0  4
  [12] .plt              PROGBITS        080482e0 0002e0 000040 04  AX  0   0 16
  [13] .text             PROGBITS        08048320 000320 0001a2 00  AX  0   0 16
  [14] .fini             PROGBITS        080484c4 0004c4 000014 00  AX  0   0  4
  [15] .rodata           PROGBITS        080484d8 0004d8 000018 00   A  0   0  4
  [16] .eh_frame_hdr     PROGBITS        080484f0 0004f0 00002c 00   A  0   0  4
  [17] .eh_frame         PROGBITS        0804851c 00051c 0000b0 00   A  0   0  4
  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4
  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4
  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4
  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4
  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        0804a000 001000 000018 04  WA  0   0  4
  [24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4
  [25] .bss              NOBITS          0804a020 001020 000004 00  WA  0   0  1
  [26] .comment          PROGBITS        00000000 001020 00002b 01  MS  0   0  1
  [27] .shstrtab         STRTAB          00000000 00104b 000106 00      0   0  1
  [28] .symtab           SYMTAB          00000000 001604 000430 10     29  45  4
  [29] .strtab           STRTAB          00000000 001a34 000251 00      0   0  1
```

反汇编 `main` 函数

```
gdb-peda$ disassemble  main
Dump of assembler code for function main:
   0x0804841d <+0>:	push   ebp
   0x0804841e <+1>:	mov    ebp,esp
   0x08048420 <+3>:	and    esp,0xfffffff0
   0x08048423 <+6>:	sub    esp,0x10
   0x08048426 <+9>:	mov    DWORD PTR [esp+0x4],0x1
   0x0804842e <+17>:	mov    DWORD PTR [esp],0x80484e0
   0x08048435 <+24>:	call   0x80482f0 <printf@plt>
   0x0804843a <+29>:	mov    eax,0x0
   0x0804843f <+34>:	leave
   0x08048440 <+35>:	ret
End of assembler dump.
```

单步执行至 `0x80482f0 <printf@plt>`, 这里需要用到前面的 `.got.plt`, `.plt`的知识, 大概说一下, `0x804a00c` 为 `.got.plt` 对应函数引用地址, 由于未初始化, `0x804a00c ` 存放的就是下一句的地址 `0x080482f6`, 之后跳到 `0x80482e0` 开始进行初始化相关操作 

```
gdb-peda$ disassemble
Dump of assembler code for function printf@plt:
=> 0x080482f0 <+0>:	jmp    DWORD PTR ds:0x804a00c
   0x080482f6 <+6>:	push   0x0
   0x080482fb <+11>:	jmp    0x80482e0
End of assembler dump.
gdb-peda$ x/w 0x804a00c
0x804a00c <printf@got.plt>:	0x080482f6
```

`0x804a008` 该地址预放了 `_dl_runtime_resolve` 函数的地址(`.got.plt`表的第三项), 因为会跳到 `_dl_runtime_resolve ` 进行初始化工作. 这里通过两次 `push` 操作, 其实是向 `_dl_fixup` 传入两个参数, 一个是需要重定位符号的偏移, 一个是 `link_map` 的地址

```
gdb-peda$ x/4i 0x80482e0
   0x80482e0:	push   DWORD PTR ds:0x804a004
=> 0x80482e6:	jmp    DWORD PTR ds:0x804a008
   0x80482ec:	add    BYTE PTR [eax],al
   0x80482ee:	add    BYTE PTR [eax],al
gdb-peda$ x/w 0x804a008
0x804a008:	0xb7ff24b0
gdb-peda$ disassemble 0xb7ff24b0
Dump of assembler code for function _dl_runtime_resolve:
   0xb7ff24b0 <+0>:	push   eax
   0xb7ff24b1 <+1>:	push   ecx
   0xb7ff24b2 <+2>:	push   edx
   0xb7ff24b3 <+3>:	mov    edx,DWORD PTR [esp+0x10]
   0xb7ff24b7 <+7>:	mov    eax,DWORD PTR [esp+0xc]
   0xb7ff24bb <+11>:	call   0xb7fec080 <_dl_fixup>
   0xb7ff24c0 <+16>:	pop    edx
   0xb7ff24c1 <+17>:	mov    ecx,DWORD PTR [esp]
   0xb7ff24c4 <+20>:	mov    DWORD PTR [esp],eax
   0xb7ff24c7 <+23>:	mov    eax,DWORD PTR [esp+0x4]
   0xb7ff24cb <+27>:	ret    0xc
End of assembler dump.
```

这里暂时不管 `_dl_fixup` 细节, 可以发现初始化完毕后 `.got.plt` 中第四项变为 `printf` 真实地址, 同时 `ret 0xc(参数表明pop多少字节)` 跳转到 `printf` 继续执行.

```
gdb-peda$ info registers sp
sp             0xbffff66c	0xbffff66c
gdb-peda$ x/4w 0xbffff66c #sp地址
0xbffff66c:	0xb7e71410	0x00000001	0xb7fff938	0x00000000
gdb-peda$ x/4w 0x0804a000 # .got.plt 函数引用表
0x804a000:	0x08049f14	0xb7fff938	0xb7ff24b0	0xb7e71410
gdb-peda$ disassemble _dl_runtime_resolve
Dump of assembler code for function _dl_runtime_resolve:
   0xb7ff24b0 <+0> : 	push   eax
   0xb7ff24b1 <+1> : 	push   ecx
   0xb7ff24b2 <+2> : 	push   edx
   0xb7ff24b3 <+3> : 	mov    edx,DWORD PTR [esp+0x10]
   0xb7ff24b7 <+7> : 	mov    eax,DWORD PTR [esp+0xc]
   0xb7ff24bb <+11>:	call   0xb7fec080 <_dl_fixup>
   0xb7ff24c0 <+16>:	pop    edx
   0xb7ff24c1 <+17>:	mov    ecx,DWORD PTR [esp]
   0xb7ff24c4 <+20>:	mov    DWORD PTR [esp],eax
   0xb7ff24c7 <+23>:	mov    eax,DWORD PTR [esp+0x4]
=> 0xb7ff24cb <+27>:	ret    0xc
End of assembler dump.
```

当跳到 `.plt` 进行重定位时进行了 `push   0x0 `, 其中 `0x0` 相当于 `.rel.plt` 中的偏移量, 根据 `Elf32_Rel` 结构进行重定位, `printf_retloc.r_offset= 0x0804a00c` 对应 `.got.plt` 中的第四项, 

```
gdb-peda$ x/8x 0x0804829c # .rel.plt 重定位表
0x804829c:	0x0804a00c	0x00000107	0x0804a010	0x00000207
0x80482ac:	0x0804a014	0x00000307	0x08ec8353	0x000093e8
```

#### 分析 `_dl_fixup` 函数(`eglibc-2.19/elf/dl-runtime.c`)

参考链接:

```
http://blog.chinaunix.net/uid-21471835-id-441227.html
```

先把几个宏定义列举出来 (`eglibc-2.19/sysdeps/i386/ldsodefs.h`)

```
/* All references to the value of l_info[DT_PLTGOT],
  l_info[DT_STRTAB], l_info[DT_SYMTAB], l_info[DT_RELA],
  l_info[DT_REL], l_info[DT_JMPREL], and l_info[VERSYMIDX (DT_VERSYM)]
  have to be accessed via the D_PTR macro.  The macro is needed since for
  most architectures the entry is already relocated - but for some not
  and we need to relocate at access time.  */
#ifdef DL_RO_DYN_SECTION
# define D_PTR(map, i) ((map)->i->d_un.d_ptr + (map)->l_addr)
#else
# define D_PTR(map, i) (map)->i->d_un.d_ptr
#endi

/* Result of the lookup functions and how to retrieve the base address.  */
typedef struct link_map *lookup_t;
#define LOOKUP_VALUE(map) map
#define LOOKUP_VALUE_ADDRESS(map) ((map) ? (map)->l_addr : 0
```

```
_dl_fixup (
# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,
# endif
	   struct link_map *l, ElfW(Word) reloc_arg) // 两个参数, link_map 地址, 需要重定位符号的偏移
{
  // D_PTR :访问 link_map 必须通过这个宏
  // 动态链接符号表
  const ElfW(Sym) *const symtab
    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);
  // 动态链接字符串表
  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
  
  // reloc_offset即_dl_fixup的第二个参数, 函数符号在 `.rel.plt` 中的偏移.
  // 获取对应重定位表中的结构
  const PLTREL *const reloc
    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);
  # 获取对应符号表的结构
  const ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)];
  # 获取需要重定向入口, 根据 R_386_JUMP_SLOT 计算方法, 对应 `.got.plt` 中函数引用地址
  void *const rel_addr = (void *)(l->l_addr + reloc->r_offset);
  lookup_t result;
  DL_FIXUP_VALUE_TYPE value;

  /* Sanity check that we're really looking at a PLT relocation.  */
  /* 检查重定位方式必须是ELF_MACHINE_JMP_SLOT */
  assert (ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT);

   /* Look up the target symbol.  If the normal lookup rules are not
      used don't look in the global scope.  */
  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)
    {
      const struct r_found_version *version = NULL;

      if (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
	{
	  const ElfW(Half) *vernum =
	    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc->r_info)] & 0x7fff;
	  version = &l->l_versions[ndx];
	  if (version->hash == 0)
	    version = NULL;
	}

      /* We need to keep the scope around so do some locking.  This is
	 not necessary for objects which cannot be unloaded or when
	 we are not using any threads (yet).  */
      int flags = DL_LOOKUP_ADD_DEPENDENCY;
      if (!RTLD_SINGLE_THREAD_P)
	{
	  THREAD_GSCOPE_SET_FLAG ();
	  flags |= DL_LOOKUP_GSCOPE_LOCK;
	}

#ifdef RTLD_ENABLE_FOREIGN_CALL
      RTLD_ENABLE_FOREIGN_CALL;
#endif
      // 查找定义该符号的模块的装载地址, result的类型为link_map, 注意这里调用后, sym 变为 libc.so.6 中的printf的符号Sym结构,sym->st_value 为printf符号在libc.so.6中段偏移
      result = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym, l->l_scope,
				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);

      /* We are done with the global scope.  */
      if (!RTLD_SINGLE_THREAD_P)
	THREAD_GSCOPE_RESET_FLAG ();

#ifdef RTLD_FINALIZE_FOREIGN_CALL
      RTLD_FINALIZE_FOREIGN_CALL;
#endif

      /* Currently result contains the base load address (or link map)
	 of the object that defines sym.  Now add in the symbol
	 offset.  */
	 /* 根据模块装载地址和函数符号的段偏移获得函数的实际地址 */
      value = DL_FIXUP_MAKE_VALUE (result,
				   sym ? (LOOKUP_VALUE_ADDRESS (result)
					  + sym->st_value) : 0);
    }
  else
    {
      /* We already found the symbol.  The module (and therefore its load
	 address) is also known.  */
      value = DL_FIXUP_MAKE_VALUE (l, l->l_addr + sym->st_value);
      result = l;
    }

  /* And now perhaps the relocation addend.  */
  value = elf_machine_plt_value (l, reloc, value);

  if (sym != NULL
      && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0))
    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));

  /* Finally, fix up the plt itself.  */
  if (__builtin_expect (GLRO(dl_bind_not), 0))
    return value;
  
  # 修正.got.plt函数引用地址(rel_addr)的值为printf的地址
  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);
}

```

```
gdb-peda$ p reloc->r_info //重定位符号在符号表中的索引
$1 = 0x107
gdb-peda$ p reloc->r_offset //重定位的入口偏移
$2 = 0x804a00c
gdb-peda$ p sym //未执行_dl_lookup_symbol_x
$3 = (const Elf32_Sym *) 0x80481dc

gdb-peda$ p sym //执行_dl_lookup_symbol_x后
$2 = (const Elf32_Sym *) 0xb7e2a6d4
gdb-peda$ p sym->st_value //执行_dl_lookup_symbol_x后, sym指向发生改变, printf符号的在libc.so.6段偏移
$9 = 0x4d410
gdb-peda$ p result->l_addr //模块装载地址
$10 = 0xb7e24000
gdb-peda$ disassemble 0x4d410+0xb7e24000
Dump of assembler code for function __printf:
   0xb7e71410 <+0>:	push   ebx
   0xb7e71411 <+1>:	sub    esp,0x18
   0xb7e71414 <+4>:	call   0xb7f4a7db <__x86.get_pc_thunk.bx>
   0xb7e71419 <+9>:	add    ebx,0x15dbe7
   0xb7e7141f <+15>:	lea    eax,[esp+0x24]
   0xb7e71423 <+19>:	mov    DWORD PTR [esp+0x8],eax
   0xb7e71427 <+23>:	mov    eax,DWORD PTR [esp+0x20]
   0xb7e7142b <+27>:	mov    DWORD PTR [esp+0x4],eax
   0xb7e7142f <+31>:	mov    eax,DWORD PTR [ebx-0x70]
   0xb7e71435 <+37>:	mov    eax,DWORD PTR [eax]
   0xb7e71437 <+39>:	mov    DWORD PTR [esp],eax
   0xb7e7143a <+42>:	call   0xb7e67810 <_IO_vfprintf_internal>
   0xb7e7143f <+47>:	add    esp,0x18
   0xb7e71442 <+50>:	pop    ebx
   0xb7e71443 <+51>:	ret
End of assembler dump.
```

---
## 动态链接加载过程

参考链接:

```
https://www.ibm.com/developerworks/cn/linux/l-elf/part1/
```

---

## 调试命令相关
#### 查看 `DYNAMIC`信息
`readelf -d test`

#### 查看 `Section Headers`
`readelf -S test`

---

## 参考链接

[Intel平台下Linux中ELF文件动态链接的加载、解析及实例分析（一）: 加载](https://www.ibm.com/developerworks/cn/linux/l-elf/part1/)

[ELF文件格式资料 ](http://blog.chinaunix.net/uid-21471835-id-441213.html)