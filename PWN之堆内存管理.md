## 参考资料

```
#libc源码, 本文的核心
http://www.eglibc.org/cgi-bin/viewvc.cgi/branches/eglibc-2_19/

#非常详细, 本文的核心
<docs/glibc内存管理ptmalloc源代码分析.pdf>

#这篇文章也不错, 很全面
http://tyrande000.how/2016/02/20/linux%E4%B8%8B%E7%9A%84%E5%A0%86%E7%AE%A1%E7%90%86/

#阿里聚安全, 只讲了及基本的数据结构, 对于具体的分配, 回收算法没有涉及到
https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.ZP7WcS&articleid=315

#很多人引用了这篇文章, 关于堆布局的图都是采用这篇文章里的
https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?spm=a313e.7916648.0.0.H9xzd9

#glibc的调试相关
http://blog.chinaunix.net/uid-24774106-id-3526766.html
http://blog.chinaunix.net/uid-24774106-id-3642925.html
http://stackoverflow.com/questions/10000335/how-to-use-debug-version-of-libc
```

关于堆的分配原理我觉的这篇文章 `<refs/glibc内存管理ptmalloc源代码分析.pdf>` 已经说得很详细. 但是我尽力用 glibc 源码 和 自己的理解总结去概述, 本文章尽力去引用 `glibc-2.19` 中具体的代码和介绍, 以及用一些实例代码作为验证.

##分析堆的相关工具

在 Phrack 的一篇文章中 `<Advanced Doug Lea's malloc exploits>`, 有一小节讲到 `Heap layout analysis` 作者利用了 `main_arena` 这个静态全局变量, 进行 heap dump 工作, 这里需要注意的是, 需要安装 `libc6-dbg` 以获取 `debugging symbols`, 此细节部分请查看 `参考资料/glibc的调试相关`.

这里介绍几个工具, 用于堆空间分配的分析.

```
#下面几个工具都是解析堆空间分配的
#简单介绍下原理, 都是采用py的gdb的API, 关于API有一篇文章
https://sourceware.org/gdb/onlinedocs/gdb/Breakpoints-In-Python.html#Breakpoints-In-Python
#之后通过cat /proc/PID/maps获取 heap base, 通过gdb的 `x/` 查看内存, 通过 `debugging symbols` 获取 `main_arena` 地址
https://github.com/cloudburst/libheap
https://github.com/Mipu94/peda-heap
https://github.com/hugsy/gef
https://github.com/pwndbg/pwndbg

#通过so注入跟踪内存分配函数
https://github.com/nihilus/HeapTracer/blob/master/linux-native
```

## 堆内存数据结构
### malloc

建议先了解一下 malloc, 请参考 `eglibc-2.19/malloc/malloc.c:44`, 会指出一些默认参数值, 以及关于 chunk 的最小 size 和 对齐的相关说明. 这里列出来了一小部分.

```
  Supported pointer representation:       4 or 8 bytes
  Supported size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.
       You can adjust this by defining INTERNAL_SIZE_T

  Alignment:                              2 * sizeof(size_t) (default)
       (i.e., 8 byte alignment with 4byte size_t). This suffices for
       nearly all current machines and C compilers. However, you can
       define MALLOC_ALIGNMENT to be wider than this if necessary.

  Minimum overhead per allocated chunk:   4 or 8 bytes
       Each malloced chunk has a hidden word of overhead holding size
       and status information.

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
			  8-byte ptrs:  24/32 bytes (including, 4/8 overhead)

       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are
       needed; 4 (8) for a trailing size field and 8 (16) bytes for
       free list pointers. Thus, the minimum allocatable size is
       16/24/32 bytes.

       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.

       The maximum overhead wastage (i.e., number of extra bytes
       allocated than were requested in malloc) is less than or equal
       to the minimum size, except for requests >= mmap_threshold that
       are serviced via mmap(), where the worst case wastage is 2 *
       sizeof(size_t) bytes plus the remainder from a system page (the
       minimal mmap unit); typically 4096 or 8192 bytes.

```

### `chunk`

malloc 产生的内存块结构.

#### chunk 结构

这里先贴出一段 `glibc-2.19/malloc/malloc.c` 中关于 chunk 的解释. 不再详细解释.

`boundary tag` 边界标记布局

`INTERNAL_SIZE_T` 头部损耗, 参考 `eglibc-2.19/malloc/malloc.c:299`, 其实也就是 `size_t`.

```
eglibc-2.19/malloc/malloc.c:1094
/*
  -----------------------  Chunk representations -----------------------
*/


/*
  This struct declaration is misleading (but accurate and necessary).
  It declares a "view" into memory allowing access to necessary
  fields at known offsets from a given base. See explanation below.
*/

struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};


/*
   malloc_chunk details:

    (The following includes lightly edited explanations by Colin Plumb.)

    Chunks of memory are maintained using a `boundary tag' method as
    described in e.g., Knuth or Standish.  (See the paper by Paul
    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a
    survey of such techniques.)  Sizes of free chunks are stored both
    in the front of each chunk and at the end.  This makes
    consolidating fragmented chunks into bigger chunks very fast.  The
    size fields also hold bits representing whether chunks are free or
    in use.

    An allocated chunk looks like this:


    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of previous chunk, if allocated            | |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of chunk, in bytes                       |M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             User data starts here...                          .
      .                                                               .
      .             (malloc_usable_size() bytes)                      .
      .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of chunk                                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    Where "chunk" is the front of the chunk for the purpose of most of
    the malloc code, but "mem" is the pointer that is returned to the
    user.  "Nextchunk" is the beginning of the next contiguous chunk.

    Chunks always begin on even word boundaries, so the mem portion
    (which is returned to the user) is also on an even word boundary, and
    thus at least double-word aligned.

    Free chunks are stored in circular doubly-linked lists, and look like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of previous chunk                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Forward pointer to next chunk in list             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Back pointer to previous chunk in list            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Unused space (may be 0 bytes long)                .
      .                                                               .
      .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    The P (PREV_INUSE) bit, stored in the unused low-order bit of the
    chunk size (which is always a multiple of two words), is an in-use
    bit for the *previous* chunk.  If that bit is *clear*, then the
    word before the current chunk size contains the previous chunk
    size, and can be used to find the front of the previous chunk.
    The very first chunk allocated always has this bit set,
    preventing access to non-existent (or non-owned) memory. If
    prev_inuse is set for any given chunk, then you CANNOT determine
    the size of the previous chunk, and might even get a memory
    addressing fault when trying to do so.

    Note that the `foot' of the current chunk is actually represented
    as the prev_size of the NEXT chunk. This makes it easier to
    deal with alignments etc but can be very confusing when trying
    to extend or adapt this code.

    The two exceptions to all this are

     1. The special chunk `top' doesn't bother using the
  trailing size field since there is no next contiguous chunk
  that would have to index off it. After initialization, `top'
  is forced to always exist.  If it would become less than
  MINSIZE bytes long, it is replenished.

     2. Chunks allocated via mmap, which have the second-lowest-order
  bit M (IS_MMAPPED) set in their size fields.  Because they are
  allocated one-by-one, each must contain its own trailing size field.

*/

```

`P (PREV_INUSE)` 标志位表示前一个 chunk 是否在使用, 0 为没有在使用.

`prev_size` 表示前一个 chunk 的大小, 仅在 `P (PREV_INUSE)` 为 0 时有效.

`size` 表示该整个 chunk 大小, 并非 malloc 返回值.

`fd`, `bk`, `fd_nextsize`, `fd_nextsize` 是对于空闲 chunk 而言, 对于正在使用分配的 chunk,从此开始 就是 malloc 返回的用户可用的空间.

`fd`, `bk`, 双向节点.

对于正在使用的 chunk 空间布局, 见上, 是一块连续内存.

对于空闲的 chunk 空间布局, 见上, 是环形双向链表. 存放在空闲 chunk 容器中.

关于 chunk 有一些操作, 判断前一个是否在使用? 是不是 `mmap` 分配的, 以及对标志位 `P` 等的操作, 可以参考 `glibc-2.19/malloc/malloc.c:1206` 中 `Physical chunk operations` 一小节(直接搜素该关键字即可).

#### 边界标示
对于已分配的 chunk 的空间布局组织采用边界标示的方法, 原理就是上面的 chunk 的内存结构, 这里涉及到 chunk 到 用户请求 mem 的想换转化操作, 以及对齐操作. 请参考 `glibc-2.19/malloc/malloc.c:1258`

#### 空间复用
对于已分配的 chunk, **它的下一个 chunk 的 `prev_size`** 是无效的, 所以这块内存被当前 chunk 给借用了, 因此对于已分配正在使用的 chunk 大小分配公式是 `chunk_size = (用户请求大小 + (2 - 1) * sizeof(INTERNAL_SIZE_T)) align to double-word`

#### 空闲 chunk 容器: Bins

```
eglibc-2.19/malloc/malloc.c:1341
/*
   -------------------- Internal data structures --------------------

   All internal state is held in an instance of malloc_state defined
   below. There are no other static variables, except in two optional
   cases:
 * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.
 * If mmap doesn't support MAP_ANONYMOUS, a dummy file descriptor
     for mmap.

   Beware of lots of tricks that minimize the total bookkeeping space
   requirements. The result is a little over 1K bytes (for 4byte
   pointers and size_t.)
 */

/*
   Bins

    An array of bin headers for free chunks. Each bin is doubly
    linked.  The bins are approximately proportionally (log) spaced.
    There are a lot of these bins (128). This may look excessive, but
    works very well in practice.  Most bins hold sizes that are
    unusual as malloc request sizes, but are more usual for fragments
    and consolidated sets of chunks, which is what these bins hold, so
    they can be found quickly.  All procedures maintain the invariant
    that no consolidated chunk physically borders another one, so each
    chunk in a list is known to be preceeded and followed by either
    inuse chunks or the ends of memory.

    Chunks in bins are kept in size order, with ties going to the
    approximately least recently used chunk. Ordering isn't needed
    for the small bins, which all contain the same-sized chunks, but
    facilitates best-fit allocation for larger chunks. These lists
    are just sequential. Keeping them in order almost never requires
    enough traversal to warrant using fancier ordered data
    structures.

    Chunks of the same size are linked with the most
    recently freed at the front, and allocations are taken from the
    back.  This results in LRU (FIFO) allocation order, which tends
    to give each chunk an equal opportunity to be consolidated with
    adjacent freed chunks, resulting in larger free chunks and less
    fragmentation.

    To simplify use in double-linked lists, each bin header acts
    as a malloc_chunk. This avoids special-casing for headers.
    But to conserve space and improve locality, we allocate
    only the fd/bk pointers of bins, and then use repositioning tricks
    to treat these as the fields of a malloc_chunk*.
 */ ≤∆
```

ptmalloc 采用分箱式管理空闲 chunk, 也就是 bins. bins 就是一个数组, 每一个存放的是一个 chunk 双向环的头结点. 相同 size 的 chunk 才能组成一个环, bins 中是按大小依次进行存放.

#### small bins, large bins
对于 chunk 大小 `< 512`, 是存放在 small bins, 有 64 个, 每个 bin 是以 8 bytes 作为分割边界, 也就相当于等差序列, 举个例子: small bins 中存放的第一个 chunk 双向环全部都是由 16 bytes 大小的 chunk 组成的, 第二个 chunk 双向环都是 16+8 bytes 大小的 chunk 组成的. 但是对于 large bins, 分割边界是递增的. 以上仅为字长为 32 位的情况下, 具体请参考如下.

```
eglibc-2.19/malloc/malloc.c:1436
/*
   Indexing

    Bins for sizes < 512 bytes contain chunks of all the same size, spaced
    8 bytes apart. Larger bins are approximately logarithmically spaced:

    64 bins of size       8
    32 bins of size      64
    16 bins of size     512
     8 bins of size    4096
     4 bins of size   32768
     2 bins of size  262144
     1 bin  of size what's left

    There is actually a little bit of slop in the numbers in bin_index
    for the sake of speed. This makes no difference elsewhere.

    The bins top out around 1MB because we expect to service large
    requests via mmap.

    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be
    a valid chunk size the small bins are bumped up one.
 */
```

这涉及到如何根据 size 进行 bin 的定位, 可以参考 `eglibc-2.19/malloc/malloc.c::1460`

#### Fastbins

关于 Fastbins 的介绍, 可以参考 `eglibc-2.19/malloc/malloc.c::1570`

```
/*
   Fastbins

    An array of lists holding recently freed small chunks.  Fastbins
    are not doubly linked.  It is faster to single-link them, and
    since chunks are never removed from the middles of these lists,
    double linking is not necessary. Also, unlike regular bins, they
    are not even processed in FIFO order (they use faster LIFO) since
    ordering doesn't much matter in the transient contexts in which
    fastbins are normally used.

    Chunks in fastbins keep their inuse bit set, so they cannot
    be consolidated with other free chunks. malloc_consolidate
    releases all chunks in fastbins and consolidates them with
    other free chunks.
 */

```

存放最近释放的小 chunk, 当进行内存分配时先从 Fastbins 中进行查找, 之后才在 bins 进行查找; 释放内存时, 当内存大小 `< max_fast` 会先存放到 Fastbins, 但如果前后存在空间的 chunk 会直接进行合并.

另一个需要注意的点就是 Fastbins 的合并, 也就是 `malloc_consolidate` 这个函数, 关于这个有几个注意的点.

** 什么时候触发 `malloc_consolidate`(仅对 `_int_malloc` 函数而言) ? **

1. small bins 尚未初始化
2. 需要 chunk 的 size 大于 small bins
3. 分配大小超过 top chunk()

** `malloc_consolidate` 如何进行合并 ?**

遍历 Fastbins 中的 chunk, 设置每个 chunk 的空闲标志位为 0, 并合并该 chunk 相邻的空闲 chunk, 之后把该 chunk 存放到 unsorted bin 中.

#### Unsorted bin
只有一个 unsorted bin, 进行内存分配查找时先在 Fastbins, small bins 中查找, 之后会在 unsorted bin 中进行查找, 并整理 unsorted bin 中所有的 chunk 到对应的 bin 中, 所以可以认为 unsorted bin 是一个缓冲区. unsorted bin 位于 `bin[1]`.

#### top chunk

以下引用来自 `glibc内存管理ptmalloc源代码分析.pdf`.

> 对于非主分配区会预先从 mmap 区域分配一块较大的空闲内存模拟 sub-heap,通过管 理 sub-heap 来响应用户的需求,因为内存是按地址从低向高进行分配的,在空闲内存的最 高处,必然存在着一块空闲 chunk,叫做 top chunk.当 bins 和 fast bins 都不能满足分配需 要的时候,ptmalloc 会设法在 top chunk 中分出一块内存给用户,如果 top chunk 本身不够大, 分配程序会重新分配一个 sub-heap,并将 top chunk 迁移到新的 sub-heap 上, 新的 sub-heap 与已有的 sub-heap 用单向链表连接起来,然后在新的 top chunk 上分配所需的内存以满足分 配的需要,实际上,top chunk 在分配时总是在 fast bins 和 bins 之后被考虑,所以,不论 top chunk 有多大,它都不会被放到 fast bins 或者是 bins 中.Top chunk 的大小是随着分配和回 收不停变换的,如果从 top chunk 分配内存会导致 top chunk 减小,如果回收的 chunk 恰好 与 top chunk 相邻,那么这两个 chunk 就会合并成新的 top chunk,从而使 top chunk 变大. 如果在 free 时回收的内存大于某个阈值,并且 top chunk 的大小也超过了收缩阈值,ptmalloc 会收缩 sub-heap,如果 top-chunk 包含了整个 sub-heap,ptmalloc 会调用 munmap 把整个 sub-heap 的内存返回给操作系统.

> 由于主分配区是唯一能够映射进程 heap 区域的分配区,它可以通过 sbrk()来增大或是 收缩进程 heap 的大小,ptmalloc 在开始时会预先分配一块较大的空闲内存 (也就是所谓 的 heap), 主分配区的 top chunk 在第一次调用 malloc 时会分配一块(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap,用户从 top chunk 分配内存时,可以直接取出一块内 存给用户.在回收内存时,回收的内存恰好与 top chunk 相邻则合并成新的 top chunk,当该 次回收的空闲内存大小达到某个阈值,并且 top chunk 的大小也超过了收缩阈值,会执行内 存收缩,减小 top chunk 的大小,但至少要保留一个页大小的空闲内存,从而把内存归还给 操作系统.如果向主分配区的 top chunk 申请内存,而 top chunk 中没有空闲内存, ptmalloc 会调用 sbrk()将的进程 heap 的边界 brk 上移, 然后修改 top chunk 的大小.

#### mmaped chunk
> 当需要分配的 chunk 足够大,而且 fast bins 和 bins 都不能满足要求,甚至 top chunk 本 身也不能满足分配需求时,ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空 间.这样分配的 chunk 在被 free 时将直接解除映射,于是就将内存归还给了操作系统,再 次对这样的内存区的引用将导致 segmentation fault 错误.这样的 chunk 也不会包含在任何 bin 中.

#### Last remainder

> Last remainder 是另外一种特殊的 chunk,就像 top chunk 和 mmaped chunk 一样,不会 在任何 bins 中找到这种 chunk.当需要分配一个 small chunk, 但在 small bins 中找不到合适 的 chunk, 如果 last remainder chunk 的大小大于所需的 small chunk 大小,last remainder chunk 被分裂成两个 chunk, 其中一个 chunk 返回给用户, 另一个 chunk 变成新的 last remainder chuk.、

需要注意的是, 仅在请求 small chunk 才使用.

##### 分配区 malloc_state
只存在一个主分区, 但是允许多个非主分区, 主分配区域可以访问 heap 区域 和 mmap 区域, 非主分区只能访问 mmap 区域, 每次用 mmap 分配一块大小的内存当做 sub-heap, 用于模拟 heap. 具体细节可以参考 `<glibc内存管理ptmalloc源代码分析.pdf>`, 每次进行内存分配必须加锁请求一个分配区.

```
eglibc-2.19/malloc/malloc.c:1663
/*
   ----------- Internal state representation and initialization -----------
 */

struct malloc_state
{
  /* Serialize access.  */
  mutex_t mutex;

  /* Flags (formerly in max_fast).  */
  int flags;

#if THREAD_STATS
  /* Statistics for locking.  Only used if THREAD_STATS is defined.  */
  long stat_lock_direct, stat_lock_loop, stat_lock_wait;
#endif

  /* Fastbins */
  mfastbinptr fastbinsY[NFASTBINS];

  /* Base of the topmost chunk -- not otherwise kept in a bin */
  mchunkptr top;

  /* The remainder from the most recent split of a small request */
  mchunkptr last_remainder;

  /* Normal bins packed as described above */
  mchunkptr bins[NBINS * 2 - 2];

  /* Bitmap of bins */
  unsigned int binmap[BINMAPSIZE];

  /* Linked list */
  struct malloc_state *next;

  /* Linked list for free arenas.  */
  struct malloc_state *next_free;

  /* Memory allocated from the system in this arena.  */
  INTERNAL_SIZE_T system_mem;
  INTERNAL_SIZE_T max_system_mem;
};

```

关于 `malloc_init_state` 的定义在:

```
eglibc-2.19/malloc/malloc.c:1768
/*
   Initialize a malloc_state struct.

   This is called only from within malloc_consolidate, which needs
   be called in the same contexts anyway.  It is never called directly
   outside of malloc_consolidate because some optimizing compilers try
   to inline it at all call points, which turns out not to be an
   optimization at all. (Inlining it in malloc_consolidate is fine though.)
 */

static void
malloc_init_state (mstate av)
{
```

#### malloc 过程

先获取分配区指针, 这个过程设计到分配区初始化和分配区加锁, 之后使用 `_int_malloc` 进行核心的内存分配. 这里想说一点关于 `malloc_consolidate` 的过程,

```
eglibc-2.19/malloc/malloc.c:3295
/*
   ------------------------------ malloc ------------------------------
 */

static void *
_int_malloc (mstate av, size_t bytes)
{
```

本来不想阅读, 发现不读根本不了解原理, 这一段分析来自 `<glibc内存管理ptmalloc源代码分析>` 但是对其中几个步骤做了补充, 可以对比看一下 `7, 8, 9, 10` 这四个步骤. (以下针对 32 位字长)

```
ptmalloc 的响应用户内存分配要求的具体步骤为:

1) 获取分配区的锁, 为了防止多个线程同时访问同一个分配区, 在进行分配之前需要 取得分配区域的锁. 线程先查看线程私有实例中是否已经存在一个分配区, 如果存 在尝试对该分配区加锁, 如果加锁成功, 使用该分配区分配内存, 否则, 该线程搜 索分配区循环链表试图获得一个空闲（没有加锁）的分配区. 如果所有的分配区都 已经加锁, 那么 ptmalloc 会开辟一个新的分配区, 把该分配区加入到全局分配区循 环链表和线程的私有实例中并加锁, 然后使用该分配区进行分配操作. 开辟出来的 新分配区一定为非主分配区, 因为主分配区是从父进程那里继承来的. 开辟非主分 配区时会调用 mmap()创建一个 sub-heap, 并设置好 top chunk.

2) 将用户的请求大小转换为实际需要分配的 chunk 空间大小.

3) 判断所需分配 chunk 的大小是否满足 chunk_size <= max_fast (max_fast 默认为 64B),  如果是的话, 则转下一步, 否则跳到第 5 步.

4) 首先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户. 如果可以找到, 则分配结束. 否则转到下一步.

5) 判断所需大小是否处在 small bins 中, 即判断 chunk_size < 512B 是否成立. 如果 chunk 大小处在 small bins 中, 则转下一步, 否则转到第 7 步.

6) 根据所需分配的 chunk 的大小, 找到具体所在的某个 small bin, 从该 bin 的尾部摘取一个恰好满足大小的 chunk. 若成功, 则分配结束, 否则, 转到 8.

7) 到了这一步, 说明需要分配的是一块大的内存, 于是, ptmalloc 首先会遍历 Fastbins 中的 chunk, 将相邻的空闲 chunk 进行合并,  并链接到 unsorted bin 中. 对于 Fastbins 的合并是由 `malloc_consolidate` 做处理.

8) 遍历 unsorted bin 中的 chunk, 如果请求的 chunk 是一个 small chunk, 且 unsorted bin 只有一个 chunk, 并且这个 chunk 在上次分配时被使用过(也就是 last_remainder chunk), 并且 chunk 的大小大于 (分配的大小 + MINSIZE), 这种情况下就直接将该 chunk 进行切割, 分配结束, 否则继续遍历, 如果发现一个 unsorted bin 的 size 恰好等于需要分配的 size, 分配结束, 否则将根据 chunk 的空间大小将其放入 small bins 或是 large bins 中, 遍历完成后, 转入下一步.

9) 到了这一步说明需要分配的是一块大的内存, 并且 fast bins 和 unsorted bin 中所有的 chunk 都清除干净 了. 从 large bins 中按照 “smallest-first, best-fit”(最小&合适, 也就是说大于或等于所需 size 的最小 chunk) 原则, 找一个合适的 chunk, 从 中划分一块合适大小的 chunk 进行切割, 并将剩下的部分放到 unsorted bin, 若操作成功, 则分配结束, 否则转到下一步.

10) 到了这一步说明在对应的 bin 上没有找到合适的大小, 无论是 small bin 还是 large bin, 在上一步的 large bin 并不一定能找到合适的 chunk 进行切割, 因为 large bins 间隔是很大的, 假如当前的 idx 的 large bin 只有一个 chunk, 但是所需 size 大于该 chunk, 这就导致找不到合适的, 对于 small bin 类似, 只能继续 idx+1, 然后根据 bitmap 找到之后第一个非空闲的 bin, 该 bin 中的 chunk 一定可以进行切割.

11) 如果搜索 fast bins 和 bins 都没有找到合适的 chunk, 那么就需要操作 top chunk 来 进行分配了. 判断 top chunk 大小是否满足所需 chunk 的大小, 如果是, 则从 top chunk 中分出一块来. 否则转到下一步.

12) 到了这一步, 说明 top chunk 也不能满足分配要求, 所以, 于是就有了两个选择: 如 果是主分配区, 调用 sbrk(), 增加 top chunk 大小；如果是非主分配区, 调用 mmap 来分配一个新的 sub-heap, 增加 top chunk 大小；或者使用 mmap()来直接分配. 在 这里, 需要依靠 chunk 的大小来决定到底使用哪种方法. 判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值, 如果是的话, 则转下一步, 调用 mmap 分配,  否则跳到第 12 步, 增加 top chunk 的大小.

13) 使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间.  然后将内存指针返回给用户.

14) 判断是否为第一次调用 malloc, 若是主分配区, 则需要进行一次初始化工作, 分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap. 若已经初 始化过了, 主分配区则调用 sbrk()增加 heap 空间, 分主分配区则在 top chunk 中切 割出一个 chunk, 使之满足分配需求, 并将内存指针返回给用户.
```

### 下面对几种特殊的分配情况举例说明

下面一段表明 `< Fastbin size` 在释放后不会进行合并, 如果使用 gdb 查看 chunk 信息可以看到 `P` 标志位为 1, 这里需要注意的是看下一个 chunk 的 `P` 标志位, 而不是当前 chunk 的标志位, 这里就不进行演示了.

```
#include<stdio.h>
#include<stdlib.h>
void main()
{
  void *m1 = malloc(24);
  int t = 0;
  void * ms[200];

  for(t = 0; t < 200; t++)
    ms[t] = malloc(120); // default fastbin size

  malloc(24);

  for(t = 0; t < 200; t++)
    free(ms[t]);
  void *m2 = malloc(24);
  printf("%p\n",m1);
  printf("%p\n",m2);
}

// result:
λ : gcc -g -o test2 test2.c && ./test2
0x17c2010
0x17c8450
```

再举例一段在释放后会进行合并的例子.

```
#include<stdio.h>
#include<stdlib.h>
void main()
{
  void *m1 = malloc(24);
  int t = 0;
  void * ms[200];

  for(t = 0; t < 200; t++)
    ms[t] = malloc(121); // small bin size

  malloc(24);

  for(t = 0; t < 200; t++)
    free(ms[t]);
  void *m2 = malloc(24);
  printf("%p\n",m1);
  printf("%p\n",m2);
}

// result:
λ : gcc -g -o test2 test2.c && ./test2
0xeab010
0xeab030
```

下面举例说明 `malloc_consolidate` 的作用, 以及如何触发 `malloc_consolidate`. 请仔细理解 m6, m7 和 m8.

```
#include<stdio.h>
#include<stdlib.h>
void main()
{
        void *m0 = malloc(24);
        void *m1 = malloc(24);
        void *m2 = malloc(0x200);
        void *m3 = malloc(0x100);
        void *m4 = malloc(24);
        void *m5 = malloc(24);
        malloc(121);
        free(m0);
        free(m1);
        free(m2);
        free(m3);
        free(m4);
        free(m5);


        malloc(0x350);
        void *m6 = malloc(0x360);
        malloc(1210); // 触发 Fastbins 合并
        void *m7 = malloc(0x360);
        void *m8 = malloc(24);

        printf("m0,%p\n", m0);
        printf("m1,%p\n", m1);
        printf("m2,%p\n", m2);
        printf("m3,%p\n", m3);
        printf("m4,%p\n", m4);
        printf("m5,%p\n", m5);
        printf("m6,%p\n", m6);
        printf("m7,%p\n", m7);
        printf("m8,%p\n", m8);
}

result:
λ : gcc -g -o test3 test3.c && ./test3
m0,0x1bf7010
m1,0x1bf7030
m2,0x1bf7050
m3,0x1bf7260
m4,0x1bf7370
m5,0x1bf7390
m6,0x1bf77a0
m7,0x1bf7010
m8,0x1bf7380
```

下面举例说明, 当 small bins 和 large bins 没有找到对应合适 size 的 bin, 需要切割的情况.

```
#include <stdio.h>
#include <stdlib.h>

void main()
{
    void * m1 = malloc(0x200);
    malloc(121);
    void * m2 = malloc(0x401);
    malloc(121);
    free(m2);
    void * m3 = malloc(24);
    free(m1);
    void * m4 = malloc(24);
    printf("m1, %p\n", m1);
    printf("m2, %p\n", m2);
    printf("m3, %p\n", m3);
    printf("m4, %p\n", m4);
    printf("sizeof(size_t) = %ld\n", sizeof(size_t));
}

result:
λ : gcc -g -o test1 test1.c && ./test1
m1, 0x1a66010
m2, 0x1a662b0
m3, 0x1a662b0 //切割 small bins
m4, 0x1a66010 //切割 large bins
sizeof(size_t) = 8
```